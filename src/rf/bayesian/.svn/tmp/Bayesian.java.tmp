package rf.bayesian;

import java.util.List;

import rf.Utility;
import cbir.Retriever;
import cbir.image.Descriptor;
import cbir.image.DescriptorType;
import cbir.image.Image;
import cbir.interfaces.Metric;
import cbir.interfaces.RelevanceFeedback;
import cbir.metric.Gaussian;

public class Bayesian implements RelevanceFeedback {
	private double[] expectationRelevant, expectationIrrelevant;
	private double scatterWithin, scatterBetween;
	private double sigmaSquare;

	private double calculateScatterWithin(List<Image> positives,
			List<Image> negatives, double[] expectationsRelevant,
			double[] expectationsIrrelevant, DescriptorType type) {
		int NN = negatives.size();
		int NR = positives.size();
		int N = NN + NR;
		int length = expectationsRelevant.length;
		double result = 0;
		double deviationRelevant = 0;
		double deviationIrrelevant = 0;
		
		for (Image curr : positives) {
			for (int i = 0; i < length; i++) {
				deviationRelevant += Math.pow(curr.getDescriptor(type)
						.getValues()[i] - expectationRelevant[i], 2);
			}
		}
		if (NR > 1)
			deviationRelevant /= NR - 1;
		else
			deviationRelevant = 0;

		for (Image curr : negatives) {
			for (int i = 0; i < length; i++) {
				deviationIrrelevant += Math.pow(curr.getDescriptor(type)
						.getValues()[i] - expectationIrrelevant[i], 2);
			}
		}
		if (NN > 1)
			deviationIrrelevant /= NN - 1;
		else
			deviationIrrelevant = 0;

		result = ((double) NR / (double) N) * deviationRelevant
				+ ((double) NN / (double) N) * deviationIrrelevant;
		result = Math.sqrt(result);

		return result;
	}

	private double calculateScatterBetween(double[] expectationsRelevant,
			double[] expectationsIrrelevant) {
		double result = 0;
		for (int i = 0; i < expectationsRelevant.length; i++) {
			result += Math.pow(expectationsRelevant[i]
					- expectationsIrrelevant[i], 2);

		}
		result = Math.sqrt(result);
		;
		return result;
	}

	/**
	 * positives and negatives must have at least a length of 2 otherwise the
	 * sigma computation wont work
	 */
	@Override
	public List<Image> relevanceFeedbackIteration(Retriever retriever,
			Image query, DescriptorType type, Metric metric,
			List<Image> positives, List<Image> negatives, int resultAmount) {
		
		
		int NN = negatives.size();
		int NR = positives.size();
		
		if(NR == 0 && NN == 0)
			return retriever.search(query, metric, type, resultAmount);
		
		if(NR > 0)
			expectationRelevant = Utility.calculateMeans(positives, type);
		else
			expectationRelevant = new double[query.getDescriptor(type).getValues().length];
		
		if(NN > 0)
			expectationIrrelevant = Utility.calculateMeans(negatives, type);
		else
			expectationIrrelevant = new double[query.getDescriptor(type).getValues().length];
		
		scatterBetween = calculateScatterBetween(expectationRelevant,
				expectationIrrelevant);
		scatterWithin = calculateScatterWithin(positives, negatives,
				expectationRelevant, expectationIrrelevant, type);
		sigmaSquare = scatterBetween * scatterWithin;

		int length = query.getDescriptor(type).getValues().length;
		double[] shiftedQuery = new double[length];
		for (int i = 0; i < length; i++) {
			shiftedQuery[i] = expectationRelevant[i];
			double normSquare = 0;
			for (int j = 0; j < length; j++)
				normSquare += Math.pow(expectationRelevant[j]
						- expectationIrrelevant[j], 2);
			shiftedQuery[i] += (sigmaSquare / normSquare)
					* (1 - ((NR - NN) / Math.max(NR, NN)))
					* (expectationRelevant[i] - expectationIrrelevant[i]);
		}
		Descriptor descriptor = query.getDescriptor(type);
		descriptor.setValues(shiftedQuery);
		//not sure if use gaussian all the time or the given metric
		return retriever.search(query, new Gaussian(), type, resultAmount);
	}

}
